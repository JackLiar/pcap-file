//! This module contains the `PcapReader` struct which is used to read from a pcap file

use byteorder::{BigEndian, LittleEndian};

use crate::{
    Endianness,
    errors::*,
    packet::Packet,
    pcap::PcapHeader
};


/// Helper struct to parse a file
///
/// # Examples
///
/// ```no_run
/// use pcap_file::pcap::PcapParser;
///
/// let pcap = vec![0xD4,0xC3,0xB2,0xA1,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/// 0x00,0x10,0x00,0x00,0x01,0x00,0x00,0x00,0x48,0x32,0x63,0x4F,0x00,0x00,0x00,0x00,0x46,0x00,0x00,
/// 0x00,0x46,0x00,0x00,0x00,0x00,0x16,0x47,0x9D,0xF2,0xC2,0x00,0x0C,0x29,0x41,0x4B,0xE7,0x81,0x00,
/// 0x00,0x78,0x08,0x00,0x45,0x00,0x00,0x34,0x9B,0x87,0x40,0x00,0x40,0x06,0x6D,0xA0,0xC0,0xA8,0xCA,
/// 0x4F,0xC0,0xA8,0xE5,0xFB,0xC5,0x1F,0x00,0x50,0xAB,0x74,0xE2,0xEE,0x55,0x84,0xF1,0x08,0x80,0x11,
/// 0x03,0xD4,0x54,0xFD,0x00,0x00,0x01,0x01,0x08,0x0A,0x00,0x86,0x79,0xC6,0x02,0xC3,0xD4,0xDE,0x48,
/// 0x32,0x63,0x4F,0x00,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,0x0C,0x29,0x41,
/// 0x4B,0xE7,0x00,0x16,0x47,0x9D,0xF2,0xC2,0x81,0x00,0x00,0x78,0x08,0x00,0x45,0x00,0x00,0x34,0xA4,
/// 0xB9,0x00,0x00,0xFE,0x06,0xE6,0x6A,0xC0,0xA8,0xE5,0xFE,0xC0,0xA8,0xCA,0x4F,0x01,0xBB,0xB4,0x25,
/// 0x80,0xE6,0x35,0x02,0xFA,0x9B,0x16,0xC3,0x80,0x10,0x80,0x00,0x57,0xE8,0x00,0x00,0x01,0x01,0x08,
/// 0x0A,0x13,0x0D,0x62,0xB3,0x00,0x86,0x79,0xC6];
///
/// // Parse all the pcap
///
/// let (pcap_parser, mut pcap) = PcapParser::new(&pcap[..]).unwrap();
///
/// while !pcap.is_empty() {
///
///     let (packet, next_pkts) = pcap_parser.next_packet(pcap).unwrap();
///     println!("{:?}", packet);
///     pcap = next_pkts;
/// }
/// ```
#[derive(Debug)]
pub struct PcapParser {
    header: PcapHeader
}

impl PcapParser {

    pub fn new(slice: &[u8]) -> ResultParsing<(PcapParser, &[u8])> {

        let slice = slice;

        let (header, slice) = PcapHeader::from_slice(slice)?;

        let parser = PcapParser {
            header
        };

        Ok((parser, slice))
    }

    pub fn next_packet<'a>(&self, slice: &'a[u8]) -> ResultParsing<(Packet<'a>, &'a[u8])> {

        let ts_resolution = self.header.ts_resolution();

        match self.header.endianness() {
            Endianness::Big => Packet::from_slice::<BigEndian>(slice, ts_resolution),
            Endianness::Little => Packet::from_slice::<LittleEndian>(slice, ts_resolution)
        }
    }
}
